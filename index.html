import React, { useEffect, useRef, useState } from 'react';
import * as THREE from 'three';

export default function AnimalPairGame() {
  const mountRef = useRef(null);
  const [score, setScore] = useState(0);
  const [moves, setMoves] = useState(0);
  const [timeLeft, setTimeLeft] = useState(60);
  const [gameStarted, setGameStarted] = useState(false);
  const [gameOver, setGameOver] = useState(false);
  const [message, setMessage] = useState('');
  
  const gameRef = useRef({
    scene: null,
    camera: null,
    renderer: null,
    cards: [],
    flippedCards: [],
    matchedPairs: 0,
    canFlip: true,
    raycaster: new THREE.Raycaster(),
    mouse: new THREE.Vector2(),
    animationId: null,
    timerInterval: null
  });

  const animals = [
    { emoji: 'ğŸ¶', color: 0xff6b6b },
    { emoji: 'ğŸ±', color: 0x4ecdc4 },
    { emoji: 'ğŸ­', color: 0xffe66d },
    { emoji: 'ğŸ¹', color: 0xa8e6cf },
    { emoji: 'ğŸ°', color: 0xff8b94 },
    { emoji: 'ğŸ¦Š', color: 0xffa07a },
    { emoji: 'ğŸ»', color: 0x98d8c8 },
    { emoji: 'ğŸ¼', color: 0xc7ceea }
  ];
  
  const createCard = (x, z, animalData, index) => {
    const group = new THREE.Group();
    
    // Card base with unique color
    const cardGeometry = new THREE.BoxGeometry(2, 0.1, 2.8);
    const cardMaterial = new THREE.MeshPhongMaterial({ 
      color: animalData.color,
      shininess: 100 
    });
    const card = new THREE.Mesh(cardGeometry, cardMaterial);
    card.castShadow = true;
    card.receiveShadow = true;
    group.add(card);
    
    const backGeometry = new THREE.PlaneGeometry(1.8, 2.6);
    
    // Card back pattern with decorative design
    const backCanvas = document.createElement('canvas');
    backCanvas.width = 256;
    backCanvas.height = 356;
    const backCtx = backCanvas.getContext('2d');
    
    // Gradient background
    const gradient = backCtx.createLinearGradient(0, 0, 256, 356);
    gradient.addColorStop(0, '#667eea');
    gradient.addColorStop(1, '#764ba2');
    backCtx.fillStyle = gradient;
    backCtx.fillRect(0, 0, 256, 356);
    
    // Border
    backCtx.strokeStyle = '#ffffff';
    backCtx.lineWidth = 8;
    backCtx.strokeRect(12, 12, 232, 332);
    
    // Inner decorative pattern
    backCtx.strokeStyle = '#ffd700';
    backCtx.lineWidth = 3;
    
    // Diamond pattern
    backCtx.beginPath();
    backCtx.moveTo(128, 50);
    backCtx.lineTo(180, 178);
    backCtx.lineTo(128, 306);
    backCtx.lineTo(76, 178);
    backCtx.closePath();
    backCtx.stroke();
    
    backCtx.beginPath();
    backCtx.moveTo(128, 90);
    backCtx.lineTo(155, 178);
    backCtx.lineTo(128, 266);
    backCtx.lineTo(101, 178);
    backCtx.closePath();
    backCtx.stroke();
    
    // Corner decorations
    const corners = [[40, 40], [216, 40], [40, 316], [216, 316]];
    corners.forEach(([x, y]) => {
      backCtx.fillStyle = '#ffd700';
      backCtx.beginPath();
      backCtx.arc(x, y, 8, 0, Math.PI * 2);
      backCtx.fill();
    });
    
    // Center star
    backCtx.fillStyle = '#ffffff';
    backCtx.font = 'bold 60px Arial';
    backCtx.textAlign = 'center';
    backCtx.textBaseline = 'middle';
    backCtx.fillText('â­', 128, 178);
    
    const backTexture = new THREE.CanvasTexture(backCanvas);
    const backMaterial = new THREE.MeshPhongMaterial({ 
      map: backTexture,
      side: THREE.DoubleSide 
    });
    const back = new THREE.Mesh(backGeometry, backMaterial);
    back.position.y = 0.06;
    back.rotation.x = -Math.PI / 2;
    group.add(back);
    
    // Animal emoji (front)
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#ffffff';
    ctx.fillRect(0, 0, 256, 256);
    ctx.font = 'bold 180px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(animalData.emoji, 128, 128);
    
    const texture = new THREE.CanvasTexture(canvas);
    const frontMaterial = new THREE.MeshPhongMaterial({ 
      map: texture,
      side: THREE.DoubleSide 
    });
    const front = new THREE.Mesh(backGeometry, frontMaterial);
    front.position.y = -0.06;
    front.rotation.x = Math.PI / 2;
    front.visible = false;
    group.add(front);
    
    group.position.set(x, 0, z);
    group.userData = {
      animal: animalData.emoji,
      color: animalData.color,
      index,
      flipped: false,
      matched: false,
      originalY: 0,
      targetRotation: 0,
      currentRotation: 0,
      back,
      front
    };
    
    return group;
  };

  const setupGame = () => {
    const { scene, camera } = gameRef.current;
    
    // Clear existing cards
    gameRef.current.cards.forEach(card => scene.remove(card));
    gameRef.current.cards = [];
    gameRef.current.matchedPairs = 0;
    gameRef.current.flippedCards = [];
    
    // Create card pairs
    const pairs = [...animals, ...animals]
      .sort(() => Math.random() - 0.5);
    
    // 4x4 grid
    let index = 0;
    for (let row = 0; row < 4; row++) {
      for (let col = 0; col < 4; col++) {
        const x = (col - 1.5) * 2.5;
        const z = (row - 1.5) * 3.2;
        const card = createCard(x, z, pairs[index], index);
        scene.add(card);
        gameRef.current.cards.push(card);
        index++;
      }
    }
    
    camera.position.set(0, 12, 8);
    camera.lookAt(0, 0, 0);
  };

  const flipCard = (card, show) => {
    if (card.userData.matched) return;
    
    card.userData.flipped = show;
    card.userData.targetRotation = show ? Math.PI : 0;
    card.userData.front.visible = show;
    card.userData.back.visible = !show;
  };

  const checkMatch = () => {
    const { flippedCards } = gameRef.current;
    if (flippedCards.length !== 2) return;
    
    gameRef.current.canFlip = false;
    const [card1, card2] = flippedCards;
    
    setMoves(m => m + 1);
    
    if (card1.userData.animal === card2.userData.animal) {
      // Match found!
      setTimeout(() => {
        card1.userData.matched = true;
        card2.userData.matched = true;
        card1.userData.targetY = -0.5;
        card2.userData.targetY = -0.5;
        
        gameRef.current.matchedPairs++;
        setScore(s => s + 100);
        setMessage('Match! ğŸ‰');
        setTimeout(() => setMessage(''), 1000);
        
        if (gameRef.current.matchedPairs === 8) {
          setGameOver(true);
          setMessage('You Win! ğŸ†');
          clearInterval(gameRef.current.timerInterval);
        }
        
        gameRef.current.flippedCards = [];
        gameRef.current.canFlip = true;
      }, 500);
    } else {
      // No match
      setTimeout(() => {
        flipCard(card1, false);
        flipCard(card2, false);
        gameRef.current.flippedCards = [];
        gameRef.current.canFlip = true;
      }, 1000);
    }
  };

  const handleClick = (event) => {
    if (!gameStarted || gameOver || !gameRef.current.canFlip) return;
    
    const rect = mountRef.current.getBoundingClientRect();
    gameRef.current.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
    gameRef.current.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
    
    gameRef.current.raycaster.setFromCamera(gameRef.current.mouse, gameRef.current.camera);
    const intersects = gameRef.current.raycaster.intersectObjects(gameRef.current.cards, true);
    
    if (intersects.length > 0) {
      const card = intersects[0].object.parent;
      if (!card.userData.flipped && !card.userData.matched) {
        flipCard(card, true);
        gameRef.current.flippedCards.push(card);
        
        if (gameRef.current.flippedCards.length === 2) {
          checkMatch();
        }
      }
    }
  };

  const animate = () => {
    const { scene, camera, renderer, cards } = gameRef.current;
    
    // Animate card flips and movements
    cards.forEach(card => {
      // Rotation animation
      const rotDiff = card.userData.targetRotation - card.userData.currentRotation;
      if (Math.abs(rotDiff) > 0.01) {
        card.userData.currentRotation += rotDiff * 0.15;
        card.rotation.y = card.userData.currentRotation;
      }
      
      // Matched cards sink down
      if (card.userData.matched && card.userData.targetY !== undefined) {
        const yDiff = card.userData.targetY - card.position.y;
        if (Math.abs(yDiff) > 0.01) {
          card.position.y += yDiff * 0.1;
        }
      }
      
      // Hover effect
      if (!card.userData.matched) {
        card.userData.originalY = card.userData.originalY || 0;
        const targetY = card.userData.flipped ? 0.3 : 0;
        const yDiff = targetY - card.userData.originalY;
        if (Math.abs(yDiff) > 0.01) {
          card.userData.originalY += yDiff * 0.1;
          card.position.y = card.userData.originalY;
        }
      }
    });
    
    renderer.render(scene, camera);
    gameRef.current.animationId = requestAnimationFrame(animate);
  };

  const startGame = () => {
    setGameStarted(true);
    setGameOver(false);
    setScore(0);
    setMoves(0);
    setTimeLeft(60);
    setMessage('');
    setupGame();
    
    // Start timer
    gameRef.current.timerInterval = setInterval(() => {
      setTimeLeft(t => {
        if (t <= 1) {
          clearInterval(gameRef.current.timerInterval);
          setGameOver(true);
          setMessage('Time Up! ğŸ˜…');
          return 0;
        }
        return t - 1;
      });
    }, 1000);
  };

  useEffect(() => {
    if (!mountRef.current) return;

    // Scene
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87ceeb);
    
    // Camera
    const camera = new THREE.PerspectiveCamera(
      60,
      mountRef.current.clientWidth / mountRef.current.clientHeight,
      0.1,
      1000
    );
    
    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    renderer.shadowMap.enabled = true;
    mountRef.current.appendChild(renderer.domElement);
    
    // Lights
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(5, 10, 5);
    dirLight.castShadow = true;
    scene.add(dirLight);
    
    // Ground
    const groundGeometry = new THREE.PlaneGeometry(30, 30);
    const groundMaterial = new THREE.MeshPhongMaterial({ 
      color: 0x90ee90,
      side: THREE.DoubleSide 
    });
    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = Math.PI / 2;
    ground.position.y = -1;
    ground.receiveShadow = true;
    scene.add(ground);
    
    gameRef.current.scene = scene;
    gameRef.current.camera = camera;
    gameRef.current.renderer = renderer;
    
    animate();
    
    // Handle resize
    const handleResize = () => {
      if (!mountRef.current) return;
      camera.aspect = mountRef.current.clientWidth / mountRef.current.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(mountRef.current.clientWidth, mountRef.current.clientHeight);
    };
    window.addEventListener('resize', handleResize);
    
    return () => {
      window.removeEventListener('resize', handleResize);
      if (gameRef.current.animationId) {
        cancelAnimationFrame(gameRef.current.animationId);
      }
      if (gameRef.current.timerInterval) {
        clearInterval(gameRef.current.timerInterval);
      }
      if (mountRef.current && renderer.domElement) {
        mountRef.current.removeChild(renderer.domElement);
      }
      renderer.dispose();
    };
  }, []);

  return (
    <div className="w-full h-screen bg-gradient-to-b from-blue-400 to-blue-600 flex flex-col">
      {/* Header */}
      <div className="bg-white bg-opacity-90 shadow-lg p-4">
        <div className="flex justify-between items-center max-w-4xl mx-auto">
          <div className="text-xl font-bold text-blue-600">ğŸ¾ Animal Match</div>
          <div className="flex gap-6 text-sm font-semibold">
            <div className="flex flex-col items-center">
              <span className="text-gray-600">Score</span>
              <span className="text-2xl text-blue-600">{score}</span>
            </div>
            <div className="flex flex-col items-center">
              <span className="text-gray-600">Moves</span>
              <span className="text-2xl text-purple-600">{moves}</span>
            </div>
            <div className="flex flex-col items-center">
              <span className="text-gray-600">Time</span>
              <span className={`text-2xl ${timeLeft < 10 ? 'text-red-600' : 'text-green-600'}`}>
                {timeLeft}s
              </span>
            </div>
          </div>
        </div>
      </div>

      {/* Game Canvas */}
      <div 
        ref={mountRef} 
        className="flex-1 relative cursor-pointer"
        onClick={handleClick}
      />

      {/* Message Overlay */}
      {message && (
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 
                      bg-white px-8 py-4 rounded-lg shadow-2xl text-2xl font-bold text-blue-600
                      animate-bounce">
          {message}
        </div>
      )}

      {/* Start/Restart Button */}
      {(!gameStarted || gameOver) && (
        <div className="absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 
                      bg-white p-8 rounded-2xl shadow-2xl text-center">
          <h2 className="text-3xl font-bold text-blue-600 mb-4">
            {gameOver ? 'ğŸ® Game Over!' : 'ğŸ¾ Animal Match Game'}
          </h2>
          {gameOver && (
            <div className="mb-4">
              <p className="text-xl text-gray-700">Final Score: {score}</p>
              <p className="text-lg text-gray-600">Moves: {moves}</p>
            </div>
          )}
          <p className="text-gray-600 mb-6">
            {gameOver ? 'Play again?' : 'Find all 8 matching pairs!'}
          </p>
          <button
            onClick={startGame}
            className="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-8 
                     rounded-full text-xl transition-all transform hover:scale-105 shadow-lg"
          >
            {gameOver ? 'ğŸ”„ Play Again' : 'â–¶ï¸ Start Game'}
          </button>
        </div>
      )}
    </div>
  );
}